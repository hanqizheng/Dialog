# 2018-07-06

- JS基础知识
- Node.js 之 事件处理程序


## let 和 const 的查漏补缺

- ### let 和 const 都没有变量提升
```
console.log(a);
let a = 6;
// 报错

//同理对const
```
- ### 暂时性死区

```
var tmp = 5;

if (true) {
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
上段代码看似在最初定义了tmp，即使下方有let定义也应该不会影响什么，但let作为仅适用与块作用域的变量声明方式，却有着需要注意的**暂时性死区**。

凡是在块作用域内使用let声明变量，那么从块作用域开始到声明变量为止的这一块小区域就称为暂时性死区。在这个区域内使用定义的变量绝对报错！！

- 其实到这里就有一个疑问，**那为什么要引入块作用域这个概念呢**？

    首先在别的语言（C++，JAVA....)他们本身就是严格的块作用域，而JavaScript在设计开始是只有全局作用域和函数作用域两个作用域，其他比如if,else之类的都没有自己的作用域。在这个方面讲引入块作用域也算是和别的语言尽量缩小差别，以免引起不必要的麻烦。

    还有就是JavaScript本身的变量提升的特点，很容易在某种情况下就会发生内层变量因为变量提升把外层变量覆盖。

    还有一个很小但是很容易引发一些不必要的错误！！
```
for(var i = 0;i < 3;i++){
    //balabala 
    //做一些事情
}

console.log(i);//3
```
这个时候i还是3，大家都明白这是因为var声明的变量生命周期是全局，所以i在循环结束之后，不会被删掉，如果以后在用到i，忘记了这一点，很容易怎么死的都不知道。

- ### for循环的特殊作用域
```
for(let i = 0;i < 3;i++){
    let i = 'abc';
    console.log(i);//abc
}
```
i 在设置循环体部分和循环内部被let声明了两次，而console.log(i)输出的是’abc‘，这个现象可以看作for循环本身作为一个块作用域，他其实是分成两个部分的，第一个部分就是设置循环体的时候，而另一个部分就是循环内部。这个东西我现在只能用let的块作用域适用来解释。有大佬知道更准确的原因吗？

- ### const的本质
    const众所周知是定义常量用的，**但是实际上const保证的是变量指向的那块内存地址不改动**。

    对于一般的简单类型(数值，字符，布尔...)，值本身就保存在变量指向的那个地址，所以他看起来就是const保证了值不变。

    但是对于引用类型（对象，数组，函数...）这一类的引用类型，他们的变量指向的地址里面存储的是一个指针，这个指针指向的才他们真正的值，所以const在这个时候就只能保证这个指针是固定的，却无法保证这个指针指向的另一块内存中的值会不会变动了。

    所以想要让对象的数据结构完全不变可以使用 Object.freeze()来冻结对象。

## Node.js之事件驱动程序

请先允许我给自己复习几个概念（明明操作系统刚学了！！掀桌.jpg）

- ### 并发和并行
    最简单的解释

    并行，是真的同时在做很多事情。

    并发要好好说下，其实并发是在引入了线程概念后产生的，在stackOverFlow上有一位大佬的解释是并发是多个任务可以在重叠的时间段内启动，运行，完成。

    但是不是很好理解，如果真的不懂并发。其实操作系统学过一个叫做时间片轮转的算法，就是给每个进(线)程一定时间的CPU（处理机、核）使用权，各个进程之间轮流使用CPU。其实如果我们可以走到线程的微观角度，就能发现这些任务并非同时在执行，他们是交替轮流执行的。但是由于CPU处理速度很快，时间片的长度又很短，所以在我们宏观的角度上看来这些任务就像是在同时执行一样。

    解释的不准确，但可以这么理解。

- ### 阻塞和非阻塞

    还是操作系统刚学过的（我却还不熟悉，跪地.jpg）

    进程有三个基本状态，就绪，执行，阻塞。

    阻塞的最常见的触发条件就是有I/O请求来了，进程就要等待I/O，知道I/O执行完毕，才会继续往下执行。这里等待，就是进程阻塞等待。

    **node.js是单进程单线程的，但这不代表他只能顺序执行遇到I/O就阻塞等待，这样显然是不高效的，缓慢的。**

    所以今天学习了node.js的事件驱动程序

- ### 事件驱动
    事件驱动要理解起来，我要引用Dan York举的两个很经典的例子。

    1. 看病
    
        在美国去看医生，需要填写大量表格，比如保险、个人信息之类，传统的基于线程的系统（thread-based system），接待员叫到你，你需要在前台填写完成这些表格，你站着填单，而接待员坐着看你填单。你让接待员没办法接待下一个客户，除非完成你的业务。

        想让这个系统能运行的快一些，只有多加几个接待员，人力成本需要增加不少。

        基于事件的系统（event-based system）中，当你到窗口发现需要填写一些额外的表格而不仅仅是挂个号，接待员把表格和笔给你，告诉你可以找个座位填写，填完了以后再回去找他。你回去坐着填表，而接待员开始接待下一个客户。你没有阻塞接待员的服务。

        你填完表格，返回队伍中，等接待员接待完现在的客户，你把表格递给他。如果有什么问题或者需要填写额外的表格，他给你一份新的，然后重复这个过程。

        这个系统已经非常高效了，几乎大部分医生都是这么做的。如果等待的人太多，可以加入额外的接待员进行服务，但是肯定要比基于线程模式的少得多。

    2. 快餐店点餐


        在基于线程的方式中（thread-based way）你到了柜台前，把你的点餐单给收银员或者给收银员直接点餐，然后等在那直到你要的食物准备好给你。收银员不能接待下一个人，除非你拿到食物离开。想接待更多的客户，容易！加更多的收银员！

        当然，我们知道快餐店其实不是这样工作的。他们其实就是基于事件驱动方式，这样收银员更高效。只要你把点餐单给收银员，某个人已经开始准备你的食物，而同时收银员在进行收款，当你付完钱，你就站在一边而收银员已经开始接待下一个客户。在一些餐馆，甚至会给你一个号码，如果你的食物准备好了，就呼叫你的号码让你去柜台取。关键的一点是，你没有阻塞下一个客户的订餐请求。你订餐的食物做好的事件会导致某个人做某个动作（某个服务员喊你的订单号码，你听到你的号码被喊到去取食物），在编程领域，我们称这个为回调（callback function）。
    
    如果耐心看完了这两个例子，我相信绝对和我刚看完的时候一样，恍然大悟。其实Node.js的事件驱动大概就是这个样子，他不会阻塞等待I/O请求或者一系列会让当前任务进入阻塞状态的事件。

    而是当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）


```
// 引入 events 模块
var events = require('events');
// 创建 eventEmitter 对象
var eventEmitter = new events.EventEmitter();

// 创建事件处理程序
var connectHandler = function connected() {
   console.log('连接成功。');
  
   // 触发 data_received 事件 
   eventEmitter.emit('data_received');
}

// 绑定 connection 事件处理程序
eventEmitter.on('connection', connectHandler);
 
// 使用匿名函数绑定 data_received 事件
eventEmitter.on('data_received', function(){
   console.log('数据接收成功。');
});

// 触发 connection 事件 
eventEmitter.emit('connection');

console.log("程序执行完毕。");

//连接成功。
//数据接收成功。
//程序执行完毕。
```

看上面的代码，顺序就是先将一个函数与'connection'事件绑定，然后同样的给'data_received'事件绑定一个函数。绑定用eventemitter.on()来完成。

然后就是激活这个事件，使用eventemitter.emit()来触发。当触发一个事件，比如'connection‘，就会调用与之绑定的函数。

- ### EventEmitter

EventEmitter是在事件驱动中最常用的，我在这里在单独拿出来说一下EventEmitter带有的最常用的一些方法，其余的可以在使用的时候去查询。

**EventEmitter.on()**

用于绑定事件与方法，当事件被触发，则调用与之绑定的函数。

**EventEmitter.emit**

用于触发事件

**EventEmitter.addListener()**

和EventEmitter.on()没有任何区别。。。。很迷