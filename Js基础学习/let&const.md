# let & const

2018-07-06



## let 和 const 都没有变量提升
```js
console.log(a);
let a = 6;
// 报错

//同理对const
```
## 暂时性死区

```js
var tmp = 5;

if (true) {
  tmp = 'abc'; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
```
上段代码看似在最初定义了tmp，即使下方有let定义也应该不会影响什么，但let作为仅适用与块作用域的变量声明方式，却有着需要注意的**暂时性死区**。

凡是在块作用域内使用let声明变量，那么从块作用域开始到声明变量为止的这一块小区域就称为暂时性死区。在这个区域内使用定义的变量绝对报错！！

## 为什么要引入块作用域这个概念呢？

首先在别的语言（C++，JAVA....)他们本身就是严格的块作用域，而JavaScript在设计开始是只有全局作用域和函数作用域两个作用域，其他比如if,else之类的都没有自己的作用域。在这个方面讲引入块作用域也算是和别的语言尽量缩小差别，以免引起不必要的麻烦。

还有就是JavaScript本身的变量提升的特点，很容易在某种情况下就会发生内层变量因为变量提升把外层变量覆盖。

还有一个很小但是很容易引发一些不必要的错误！！
```js
for(var i = 0;i < 3;i++){
    //balabala 
    //做一些事情
}

console.log(i);//3
```
这个时候i还是3，大家都明白这是因为var声明的变量生命周期是全局，所以i在循环结束之后，不会被删掉，如果以后在用到i，忘记了这一点，很容易怎么死的都不知道。

## for循环的特殊作用域
```js
for(let i = 0;i < 3;i++){
    let i = 'abc';
    console.log(i);//abc
}
```
i 在设置循环体部分和循环内部被let声明了两次，而console.log(i)输出的是’abc‘，这个现象可以看作for循环本身作为一个块作用域，他其实是分成两个部分的，第一个部分就是设置循环体的时候，而另一个部分就是循环内部。这个东西我现在只能用let的块作用域适用来解释。有大佬知道更准确的原因吗？

## const的本质
const众所周知是定义常量用的，**但是实际上const保证的是变量指向的那块内存地址不改动**。

对于一般的简单类型(数值，字符，布尔...)，值本身就保存在变量指向的那个地址，所以他看起来就是const保证了值不变。

但是对于引用类型（对象，数组，函数...）这一类的引用类型，他们的变量指向的地址里面存储的是一个指针，

这个指针指向的才他们真正的值，所以const在这个时候就只能保证这个指针是固定的，却无法保证这个指针指向的

另一块内存中的值会不会变动了。

所以想要让对象的数据结构完全不变可以使用 Object.freeze()来冻结对象。